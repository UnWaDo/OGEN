import argparse
import os
from typing import List
import numpy as np

from openmm.app import ForceField
from OGEN.MultiWFN.CriticalPoints import SpaceFunctions
from OGEN.MultiWFN.PointsAnalysis import calculate_rsf_at_points
from OGEN.RESP.resp_points import gen_points

from OGEN.utils.constants import BOHR_TO_ANGSTROM
from OGEN.files.reader import read_molecule
from OGEN.openmm_api import get_charges_and_positions, mol_to_openmm
from OGEN.utils import get_coordinates, get_elements


def calculate_esp_error(wavefunction_path: str,
                        ff: ForceField,
                        preserve=False) -> float:

    name, _ = os.path.splitext(os.path.basename(wavefunction_path))
    esp_name = f'{name}_esp'

    structure = read_molecule(wavefunction_path)

    topology = mol_to_openmm(structure)

    atomic_coordinates = get_coordinates(structure)
    elements = get_elements(structure)

    charges, positions = get_charges_and_positions(topology,
                                                   atomic_coordinates, ff)

    if preserve and os.path.exists(esp_name):
        esp_points = np.loadtxt(esp_name)

    else:
        esp_points = gen_points(atomic_coordinates,
                                [e.upper() for e in elements])
        esp_points = calculate_rsf_at_points(
            wavefunction_path,
            esp_points,
            SpaceFunctions.ESP,
        )
        if preserve:
            np.savetxt(esp_name, esp_points)

    esps = esp_points[:, 3]
    points = esp_points[:, :-1] * BOHR_TO_ANGSTROM

    invr = np.zeros((len(points), len(positions)))

    for i in range(invr.shape[0]):
        for j in range(invr.shape[1]):
            invr[i, j] = 1 / np.linalg.norm(points[i] - positions[j])
    invr *= BOHR_TO_ANGSTROM  # convert to atomic units

    x_esp = np.einsum('ij, j -> i', invr, charges)
    return np.square(x_esp - esps).sum()


def format_line(
    name,
    esp_error,
) -> str:
    if isinstance(esp_error, str):
        return f'{name:20}{esp_error:20}'
    else:
        return f'{name:20}{esp_error:<20.5g}'


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        prog='calc_esp_error',
        description=('Calculate ESP error from '
                     'wavefunction and Openmm forcefield'))

    parser.add_argument(
        'wavefunctions',
        help='fchk or any other wavefunction file for MultiWFN',
        nargs='+',
    )
    parser.add_argument(
        '-f',
        '--forcefields',
        help='openmm-compatible forcefields',
        nargs='+',
        required=True,
    )
    parser.add_argument('--preserve',
                        action='store_true',
                        help='whether to save data generated by MultiWFN '
                        '(may be usefull for multiple calculations in a row)')

    args = parser.parse_args()

    wavefunctions: List[str] = args.wavefunctions
    forcefields: List[str] = args.forcefields
    preserve: bool = args.preserve

    ff = ForceField(*forcefields)

    print(format_line('Name', 'ESP error'))

    for wavefunction in wavefunctions:
        esp_error = calculate_esp_error(wavefunction, ff, preserve)

        name, _ = os.path.splitext(os.path.basename(wavefunction))

        print(format_line(name, esp_error))
