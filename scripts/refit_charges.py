import argparse
import os
from typing import Dict, List, Tuple

import numpy as np
from openmm.app import ForceField, Modeller, Topology

from OGEN.ForceField import ForceField as OGENFF
from OGEN.files.reader import read_molecule
from OGEN.openmm_api import get_charges_and_positions, mol_to_openmm
from OGEN.utils import get_coordinates, get_elements

from OGEN.MultiWFN.CriticalPoints import SpaceFunctions
from OGEN.MultiWFN.PointsAnalysis import calculate_rsf_at_points
from OGEN.RESP import fit_charges
from OGEN.RESP.resp_points import gen_points


def match_types(ff: ForceField, topology: Topology, charges: np.ndarray) -> Dict[str, int]:
    data = ForceField._SystemData(topology)

    chain = next(topology.chains())
    residue = next(chain.residues())
    template, matches = ff._getResidueTemplateMatches(residue, data.bondedToAtom)

    if matches is None:
        raise ValueError('Residue does not match template')
    atom_indices = template.atomIndices
    atom_types = {}
    for atom in template.atoms:
        atom_types[atom.name] = atom.type

    template_indices = {atom_indices[i]: atom_types[i] for i in atom_indices}
    return [template_indices[i] for i in matches]


def create_points(
    coordinates: np.ndarray,
    elements: List[str],
    wavefunction_path: str,
    esp_name=None,
) -> np.ndarray:
    if esp_name is not None and os.path.exists(esp_name):
        esp_points = np.loadtxt(esp_name)

    else:
        esp_points = gen_points(coordinates, [e.upper() for e in elements])

        esp_points = calculate_rsf_at_points(
            wavefunction_path,
            esp_points,
            SpaceFunctions.ESP,
        )
        if esp_name is not None:
            np.savetxt(esp_name, esp_points)
    return esp_points


def refit_charges(wavefunction: str,
                  forcefield: ForceField,
                  preserve=False,
                  output=None):
    name, _ = os.path.splitext(os.path.basename(wavefunction))

    if preserve:
        esp_name = f'{name}_esp'
    else:
        esp_name = None

    if output is None:
        output = f'{name}.xml'

    ff = ForceField(forcefield)
    structure = read_molecule(wavefunction)

    topology = mol_to_openmm(structure)
    positions = get_coordinates(structure)
    elements = get_elements(structure)

    model = Modeller(topology, positions / 10)
    model.addExtraParticles(ff)

    old_charges, positions_with_osc = get_charges_and_positions(None,
                                                                None,
                                                                ff,
                                                                model=model)
    osc_positions = positions_with_osc[len(positions):]

    types_index = match_types(ff, model.topology, old_charges)
    ogen_ff = OGENFF.from_file(forcefield)

    esp_points = create_points(positions, elements, wavefunction, esp_name)
    (_, new_charges), _ = fit_charges(
        symbols=[e.upper() for e in elements],
        coords=positions,
        sample_points=esp_points,
        extra=osc_positions,
    )

    for i, type_name in enumerate(types_index):
        for nb in ogen_ff.nonbonded_forces:
            if nb.type_name == type_name:
                break
        else:
            raise ValueError()
        if not np.isclose(old_charges[i], nb.charge):
            print(f'WARNING: charges for type {type_name} '
                  f'are not equal: {old_charges[i]} and {nb.charge}')
        nb.charge = new_charges[i]

    ogen_ff.to_xml(output)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description=('Refit charges based on '
                     'wavefunction and Openmm forcefield'))

    parser.add_argument(
        'wavefunction',
        help='fchk or any other wavefunction file for MultiWFN',
    )
    parser.add_argument(
        'forcefield',
        help='openmm-compatible forcefields',
    )
    parser.add_argument(
        '--output',
        '-o',
        help='output file name',
    )
    parser.add_argument('--preserve',
                        action='store_true',
                        help='whether to save data generated by MultiWFN '
                        '(may be usefull for multiple calculations in a row)')

    args = parser.parse_args()

    wavefunction: str = args.wavefunction
    forcefield: str = args.forcefield
    preserve: bool = args.preserve
    output: str = args.output

    refit_charges(wavefunction, forcefield, preserve, output)
